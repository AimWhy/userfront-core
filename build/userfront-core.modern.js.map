{"version":3,"file":"userfront-core.modern.js","sources":["../src/constants.js","../src/index.js","../src/user.js"],"sourcesContent":["export const apiUrl = `https://api.userfront.com/v0/`;\n\nexport const privateIPRegex =\n  /((^127\\.)|(^10\\.)|(^172\\.1[6-9]\\.)|(^172\\.2[0-9]\\.)|(^172\\.3[0-1]\\.)|(^192\\.168\\.))\\d{1,3}\\.\\d{1,3}/g;\n\nexport default {\n  apiUrl,\n  privateIPRegex,\n};\n","import axios from \"axios\";\nimport Cookies from \"js-cookie\";\nimport jwt from \"jsonwebtoken\";\nimport { JwksClient } from \"jwks-rsa\";\n\nimport { apiUrl, privateIPRegex } from \"./constants.js\";\nimport createUser from \"./user.js\";\n\nlet initCallbacks = [];\n\n/**\n * Determine whether a hostname is in test mode.\n * @param {String} hn\n */\nconst isTestHostname = (hn) => {\n  try {\n    const hostname = hn || window.location.hostname;\n    return !!(hostname.match(/localhost/g) || hostname.match(privateIPRegex));\n  } catch (err) {\n    return true;\n  }\n};\n\nconst store = {\n  mode: isTestHostname() ? \"test\" : \"live\",\n  user: {},\n};\n\n/**\n * Initialize the Userfront library.\n * @param {String} tenantId\n */\nfunction init(tenantId) {\n  if (!tenantId) return console.warn(\"Userfront initialized without tenant ID\");\n  store.tenantId = tenantId;\n  store.accessTokenName = `access.${tenantId}`;\n  store.idTokenName = `id.${tenantId}`;\n  store.refreshTokenName = `refresh.${tenantId}`;\n  setTokensFromCookies();\n\n  if (store.idToken) {\n    setUser();\n  }\n\n  try {\n    if (initCallbacks.length > 0) {\n      initCallbacks.forEach((cb) => {\n        if (!cb || typeof cb !== \"function\") return;\n        cb({ tenantId });\n      });\n    }\n    initCallbacks = [];\n  } catch (error) {}\n}\n\n/**\n * Add a callback function to be called upon Userfront.init()\n * @param {Function} cb\n */\nfunction addInitCallback(cb) {\n  if (!cb || typeof cb !== \"function\") return;\n  initCallbacks.push(cb);\n}\n\n/**\n * Set and then return the access token\n */\nfunction accessToken() {\n  store.accessToken = Cookies.get(store.accessTokenName);\n  return store.accessToken;\n}\n\n/**\n * Set and then return the ID token\n */\nfunction idToken() {\n  store.idToken = Cookies.get(store.idTokenName);\n  return store.idToken;\n}\n\n/**\n * Verify provided token was issued by Userfront API\n * @param {String} token\n * @returns {Promise<void>} The provided token has been verified if `verifyToken` resolves without error\n */\nasync function verifyToken(token) {\n  if (!token) throw new Error(\"Missing token\");\n\n  let publicKey;\n  try {\n    const decodedToken = jwt.decode(token, { complete: true });\n    if (!decodedToken.header || !decodedToken.header.kid) {\n      throw new Error(\"Token kid not defined\");\n    }\n\n    const client = new JwksClient({\n      jwksUri: `${apiUrl}tenants/${store.tenantId}/jwks/${store.mode}`,\n      requestHeaders: { origin: window.location.origin },\n    });\n\n    const key = await client.getSigningKey(decodedToken.header.kid);\n    publicKey = key.getPublicKey();\n  } catch (error) {\n    throw error;\n  }\n\n  if (!publicKey) {\n    throw new Error(\"Public key not found\");\n  }\n\n  try {\n    jwt.verify(token, publicKey);\n  } catch (error) {\n    throw new Error(\"Token verification failed\");\n  }\n\n  return Promise.resolve();\n}\n\n/**\n * Get the value of a query attribute, e.g. ?attr=value\n * @param {String} attrName\n */\nfunction getQueryAttr(attrName) {\n  if (\n    !window.location.href ||\n    window.location.href.indexOf(`${attrName}=`) < 0\n  ) {\n    return;\n  }\n  return decodeURIComponent(\n    window.location.href.split(`${attrName}=`)[1].split(\"&\")[0]\n  );\n}\n\nfunction getProviderLink(provider) {\n  if (!provider) throw new Error(\"Missing provider\");\n  if (!store.tenantId) throw new Error(\"Missing tenant ID\");\n\n  let url = `https://api.userfront.com/v0/auth/${provider}/login?tenant_id=${store.tenantId}&origin=${window.location.origin}`;\n\n  const redirect = getQueryAttr(\"redirect\");\n  if (redirect) {\n    url += `&redirect=${encodeURIComponent(redirect)}`;\n  }\n\n  return url;\n}\n\n/**\n * Define the mode of operation (live or test)\n */\nasync function setMode() {\n  try {\n    const { data } = await axios.get(`${apiUrl}tenants/${store.tenantId}/mode`);\n    store.mode = data.mode || \"test\";\n  } catch (err) {\n    store.mode = \"test\";\n  }\n}\n\n/**\n * Register a user via the provided method. This method serves to call other\n * methods, depending on the \"method\" parameter passed in.\n * @param {Object} options\n */\nasync function signup({ method, username, name, email, password }) {\n  if (!method) {\n    throw new Error('Userfront.signup called without \"method\" property');\n  }\n  switch (method) {\n    case \"azure\":\n    case \"facebook\":\n    case \"github\":\n    case \"google\":\n    case \"linkedin\":\n      return signupWithSSO(method);\n    case \"password\":\n      return signupWithPassword({ username, name, email, password });\n    default:\n      throw new Error('Userfront.signup called with invalid \"method\" property');\n  }\n}\n\n/**\n * Register a new user in via SSO provider.\n * Redirect the browser after successful authentication and 302 redirect from server.\n * @param {String} provider Name of SSO provider\n */\nfunction signupWithSSO(provider) {\n  if (!provider) throw new Error(\"Missing provider\");\n  const url = getProviderLink(provider);\n  window.location.assign(url);\n}\n\n/**\n * Register a new user with username, name, email, and password.\n * Redirect the browser after successful signup based on the redirectTo value returned.\n * @param {Object} options\n */\nasync function signupWithPassword({ username, name, email, password }) {\n  const { data } = await axios.post(`${apiUrl}auth/create`, {\n    tenantId: store.tenantId,\n    username,\n    name,\n    email,\n    password,\n  });\n\n  if (data.tokens) {\n    setCookiesAndTokens(data.tokens);\n    setUser();\n    redirectToPath(getQueryAttr(\"redirect\") || data.redirectTo || \"/\");\n  } else {\n    throw new Error(\"Please try again.\");\n  }\n}\n\n/**\n * Log a user in via the provided method. This method serves to call other\n * methods, depending on the \"method\" parameter passed in.\n * @param {Object} options\n */\nasync function login({\n  method,\n  email,\n  username,\n  emailOrUsername,\n  password,\n  token,\n  uuid,\n}) {\n  if (!method) {\n    throw new Error('Userfront.login called without \"method\" property');\n  }\n  switch (method) {\n    case \"azure\":\n    case \"facebook\":\n    case \"github\":\n    case \"google\":\n    case \"linkedin\":\n      return loginWithSSO(method);\n    case \"password\":\n      return loginWithPassword({ email, username, emailOrUsername, password });\n    case \"link\":\n      return loginWithLink(token, uuid);\n    default:\n      throw new Error('Userfront.login called with invalid \"method\" property');\n  }\n}\n\n/**\n * Log a user in via SSO provider.\n * Redirect the browser after successful authentication and 302 redirect from server.\n * @param {String} provider Name of SSO provider\n */\nfunction loginWithSSO(provider) {\n  if (!provider) throw new Error(\"Missing provider\");\n  const url = getProviderLink(provider);\n  window.location.assign(url);\n}\n\n/**\n * Log a user in with email/username and password.\n * Redirect the browser after successful login based on the redirectTo value returned.\n * @param {Object} options\n */\nasync function loginWithPassword({\n  email,\n  username,\n  emailOrUsername,\n  password,\n}) {\n  const { data } = await axios.post(`${apiUrl}auth/basic`, {\n    tenantId: store.tenantId,\n    emailOrUsername: email || username || emailOrUsername,\n    password,\n  });\n  if (data.tokens) {\n    setCookiesAndTokens(data.tokens);\n    setUser();\n    redirectToPath(getQueryAttr(\"redirect\") || data.redirectTo || \"/\");\n  } else {\n    throw new Error(\"Please try again.\");\n  }\n}\n\n/**\n * Log a user in with a token/uuid combo passed into the function or\n * in the URL querystring. ?token=...&uuid=...\n * @param {String} token\n * @param {UUID} uuid\n */\nasync function loginWithLink(token, uuid) {\n  if (!token) token = getQueryAttr(\"token\");\n  if (!uuid) uuid = getQueryAttr(\"uuid\");\n  if (!token || !uuid) return;\n\n  const { data } = await axios.put(`${apiUrl}auth/link`, {\n    token,\n    uuid,\n    tenantId: store.tenantId,\n  });\n\n  if (data.tokens) {\n    setCookiesAndTokens(data.tokens);\n    setUser();\n    redirectToPath(getQueryAttr(\"redirect\") || data.redirectTo || \"/\");\n  } else {\n    throw new Error(\"Problem logging in.\");\n  }\n}\n\n/**\n * Send a login link to the provided email.\n * @param {String} email\n */\nasync function sendLoginLink(email) {\n  try {\n    const { data } = await axios.post(`${apiUrl}auth/link`, {\n      email,\n      tenantId: store.tenantId,\n    });\n    return data;\n  } catch (err) {\n    throw new Error(\"Problem sending link\");\n  }\n}\n\n/**\n * Send a password reset link to the provided email.\n * @param {String} email\n */\nasync function sendResetLink(email) {\n  try {\n    const { data } = await axios.post(`${apiUrl}auth/reset/link`, {\n      email,\n      tenantId: store.tenantId,\n    });\n    return data;\n  } catch (err) {\n    throw new Error(\"Problem sending link\");\n  }\n}\n\nasync function resetPassword({ uuid, token, password }) {\n  if (!token) token = getQueryAttr(\"token\");\n  if (!uuid) uuid = getQueryAttr(\"uuid\");\n  if (!token || !uuid) throw new Error(\"Missing token or uuid\");\n  const { data } = await axios.put(`${apiUrl}auth/reset`, {\n    tenantId: store.tenantId,\n    uuid,\n    token,\n    password,\n  });\n  if (data.tokens) {\n    setCookiesAndTokens(data.tokens);\n    setUser();\n    redirectToPath(getQueryAttr(\"redirect\") || data.redirectTo || \"/\");\n  } else {\n    throw new Error(\n      \"There was a problem resetting your password. Please try again.\"\n    );\n  }\n}\n\n// TODO replace with direct check of the access token.\n/**\n * If the access token is valid, redirect the browser to the\n * tenant's login redirection path (path after login).\n */\nasync function redirectIfLoggedIn() {\n  if (!store.accessToken) return removeAllCookies();\n  try {\n    const { data } = await axios.get(`${apiUrl}self`, {\n      headers: {\n        authorization: `Bearer ${store.accessToken}`,\n      },\n    });\n    if (data.tenant && data.tenant.loginRedirectPath) {\n      redirectToPath(data.tenant.loginRedirectPath);\n    }\n  } catch (err) {\n    removeAllCookies();\n  }\n}\n\n/**\n * Redirect to path portion of a URL.\n */\nfunction redirectToPath(pathOrUrl) {\n  try {\n    document;\n  } catch (error) {\n    return;\n  }\n  if (!pathOrUrl) return;\n  const el = document.createElement(\"a\");\n  el.href = pathOrUrl;\n  let path = `${el.pathname}${el.hash}${el.search}`;\n  if (el.pathname !== window.location.pathname) {\n    window.location.href = path;\n  }\n}\n\n/**\n * Log a user out and redirect to the logout path.\n */\nasync function logout() {\n  if (!store.accessToken) return removeAllCookies();\n  try {\n    const { data } = await axios.get(`${apiUrl}auth/logout`, {\n      headers: {\n        authorization: `Bearer ${store.accessToken}`,\n      },\n    });\n    removeAllCookies();\n    redirectToPath(data.redirectTo);\n  } catch (err) {\n    removeAllCookies();\n  }\n}\n\n/**\n * Set a cookie value based on the given options.\n * @param {String} value\n * @param {Object} options\n * @param {String} type\n */\nfunction setCookie(value, options, type) {\n  const cookieName = `${type}.${store.tenantId}`;\n  options = options || {\n    secure: store.mode === \"live\",\n    sameSite: \"Lax\",\n  };\n  if (type === \"refresh\") {\n    options.sameSite = \"Strict\";\n  }\n  Cookies.set(cookieName, value, options);\n}\n\n/**\n * Remove a cookie by name, regardless of its cookie setting(s).\n * @param {String} name\n */\nfunction removeCookie(name) {\n  Cookies.remove(name);\n  Cookies.remove(name, { secure: true, sameSite: \"Lax\" });\n  Cookies.remove(name, { secure: true, sameSite: \"None\" });\n  Cookies.remove(name, { secure: false, sameSite: \"Lax\" });\n  Cookies.remove(name, { secure: false, sameSite: \"None\" });\n}\n\n/**\n * Remove all auth cookies (access, id, refresh).\n */\nfunction removeAllCookies() {\n  removeCookie(store.accessTokenName);\n  removeCookie(store.idTokenName);\n  removeCookie(store.refreshTokenName);\n  store.accessToken = undefined;\n  store.idToken = undefined;\n  store.refreshToken = undefined;\n}\n\n/**\n * Define the store token values from the cookie values.\n */\nfunction setTokensFromCookies() {\n  store.accessToken = Cookies.get(store.accessTokenName);\n  store.idToken = Cookies.get(store.idTokenName);\n  store.refreshToken = Cookies.get(store.refreshTokenName);\n}\n\n/**\n * Set the cookies from a tokens object, and add to the local store.\n * @param {Object} tokens\n */\nfunction setCookiesAndTokens(tokens) {\n  setCookie(tokens.access.value, tokens.access.cookieOptions, \"access\");\n  setCookie(tokens.id.value, tokens.id.cookieOptions, \"id\");\n  setCookie(tokens.refresh.value, tokens.refresh.cookieOptions, \"refresh\");\n  setTokensFromCookies();\n}\n\n/**\n * Define user attributes & methods based on access & ID token.\n */\nasync function setUser() {\n  if (!store.idToken) {\n    throw new Error(\"ID token has not been set.\");\n  }\n  if (!store.accessToken) {\n    throw new Error(\"Access token has not been set.\");\n  }\n\n  try {\n    await verifyToken(store.idToken);\n  } catch (error) {\n    throw error;\n  }\n\n  Object.assign(\n    store.user,\n    createUser({\n      store,\n      afterUpdate: refresh,\n    })\n  );\n}\n\nasync function refresh() {\n  const res = await axios.get({\n    url: `${apiUrl}auth/refresh`,\n    headers: {\n      authorization: `Bearer ${store.accessToken}`,\n    },\n  });\n  if (!res || !res.data || !res.data.tokens) {\n    throw new Error(\"Problem refreshing tokens.\");\n  }\n\n  setCookiesAndTokens(res.data.tokens);\n  setUser();\n}\n\n/**\n * Register a window-level event called \"urlchanged\" that will fire\n * whenever the browser URL changes.\n */\nlet isRegistered = false;\nfunction registerUrlChangedEventListener() {\n  if (isRegistered) return;\n  isRegistered = true;\n  try {\n    history.pushState = ((f) =>\n      function pushState() {\n        var ret = f.apply(this, arguments);\n        window.dispatchEvent(new Event(\"pushstate\"));\n        window.dispatchEvent(new Event(\"urlchanged\"));\n        return ret;\n      })(history.pushState);\n\n    history.replaceState = ((f) =>\n      function replaceState() {\n        var ret = f.apply(this, arguments);\n        window.dispatchEvent(new Event(\"replacestate\"));\n        window.dispatchEvent(new Event(\"urlchanged\"));\n        return ret;\n      })(history.replaceState);\n\n    window.addEventListener(\"popstate\", () => {\n      window.dispatchEvent(new Event(\"urlchanged\"));\n    });\n  } catch (error) {}\n}\n\nexport default {\n  addInitCallback,\n  accessToken,\n  getQueryAttr,\n  idToken,\n  init,\n  isTestHostname,\n  login,\n  logout,\n  redirectIfLoggedIn,\n  refresh,\n  registerUrlChangedEventListener,\n  resetPassword,\n  sendLoginLink,\n  sendResetLink,\n  setMode,\n  setCookie,\n  signup,\n  store,\n  get user() {\n    return store.user;\n  },\n  verifyToken,\n};\n","import axios from \"axios\";\nimport jwt from \"jsonwebtoken\";\nimport { apiUrl } from \"./constants.js\";\n\n/**\n * Create a user object based on ID token\n * @param {Object} options\n * @property {Object} options.store Userfront store\n * @property {Function} options.afterUpdate Function to call after update is finished\n * @returns {Object}\n */\nexport default ({ store, afterUpdate }) => {\n  if (!store.idToken) {\n    throw new Error(\"User: Missing ID token\");\n  }\n  if (!store.accessToken) {\n    throw new Error(\"User: Missing access token\");\n  }\n\n  const user = {};\n  const decodedIdToken = jwt.decode(store.idToken);\n\n  // Set basic user information properties from ID token\n  const idTokenProps = [\n    \"email\",\n    \"username\",\n    \"name\",\n    \"image\",\n    \"data\",\n    \"confirmedAt\",\n    \"createdAt\",\n    \"updatedAt\",\n    \"mode\",\n    \"userId\",\n    \"userUuid\",\n    \"tenantId\",\n    \"isConfirmed\",\n  ];\n  for (const prop of idTokenProps) {\n    user[prop] = decodedIdToken[prop];\n  }\n  return {\n    ...user,\n    /**\n     * Update user information via Userfront API\n     * @param {Object} updates User properties to update e.g. { name: 'John Doe' }\n     * @returns {Promise<void>}\n     */\n    async update(updates) {\n      if (!decodedIdToken.userId) {\n        throw new Error(\"API resource update error: Missing ID\");\n      }\n      if (!updates || Object.keys(updates).length < 1) {\n        throw new Error(\"Missing user properties to update\");\n      }\n\n      try {\n        await axios.put({\n          url: `${apiUrl}tenants/${store.tenantId}/users/${decodedIdToken.userId}`,\n          headers: {\n            authorization: `Bearer ${store.accessToken}`,\n          },\n          payload: updates,\n        });\n      } catch (error) {\n        throw new Error(error.message);\n      }\n\n      if (afterUpdate && typeof afterUpdate === \"function\") {\n        afterUpdate();\n      }\n\n      return Promise.resolve();\n    },\n  };\n};\n"],"names":["apiUrl","privateIPRegex","initCallbacks","isTestHostname","hn","hostname","window","location","match","err","store","mode","user","async","verifyToken","token","Error","publicKey","decodedToken","jwt","decode","complete","header","kid","client","JwksClient","jwksUri","tenantId","requestHeaders","origin","getSigningKey","getPublicKey","error","verify","Promise","resolve","getQueryAttr","attrName","href","indexOf","decodeURIComponent","split","getProviderLink","provider","url","redirect","encodeURIComponent","redirectToPath","pathOrUrl","document","el","createElement","pathname","hash","search","setCookie","value","options","type","cookieName","secure","sameSite","Cookies","set","removeCookie","name","remove","removeAllCookies","accessTokenName","idTokenName","refreshTokenName","accessToken","undefined","idToken","refreshToken","setTokensFromCookies","get","setCookiesAndTokens","tokens","access","cookieOptions","id","refresh","setUser","Object","assign","afterUpdate","decodedIdToken","idTokenProps","prop","[object Object]","updates","userId","keys","length","axios","put","headers","authorization","payload","message","createUser","res","data","isRegistered","addInitCallback","cb","push","init","console","warn","forEach","login","method","email","username","emailOrUsername","password","uuid","loginWithSSO","post","redirectTo","loginWithPassword","loginWithLink","logout","redirectIfLoggedIn","tenant","loginRedirectPath","registerUrlChangedEventListener","history","pushState","f","ret","apply","this","arguments","dispatchEvent","Event","replaceState","addEventListener","resetPassword","sendLoginLink","sendResetLink","setMode","signup","signupWithSSO","signupWithPassword"],"mappings":"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"}