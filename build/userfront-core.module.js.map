{"version":3,"file":"userfront-core.module.js","sources":["../src/constants.js","../src/utils.js","../src/store.js","../src/tokens.js","../src/cookies.js","../src/url.js","../src/user.js","../src/refresh.js","../src/signon.js","../src/index.js","../src/logout.js","../src/mode.js"],"sourcesContent":["export const apiUrl = `https://api.userfront.com/v0/`;\n\nexport const privateIPRegex =\n  /((^127\\.)|(^10\\.)|(^172\\.1[6-9]\\.)|(^172\\.2[0-9]\\.)|(^172\\.3[0-1]\\.)|(^192\\.168\\.))\\d{1,3}\\.\\d{1,3}/g;\n","/**\n * This file is for zero-dependency utilities that can\n * be imported by any other file. Don't add any imports\n * to this file other than constants\n */\n\nimport { privateIPRegex } from \"./constants.js\";\n\n/**\n * Determine whether a hostname is in test mode.\n * @param {String} hn\n */\nexport function isTestHostname(hn) {\n  try {\n    const hostname = hn || window.location.hostname;\n    return !!(hostname.match(/localhost/g) || hostname.match(privateIPRegex));\n  } catch (err) {\n    return true;\n  }\n}\n\n/**\n * Get the unverified base64 decoded payload of a JWT\n *\n * @param {String} token - JSON Web Token\n * @returns {Object}\n */\nexport function getJWTPayload(token) {\n  try {\n    const encodedPayload = token\n      .split(\".\")[1]\n      .replace(\"-\", \"+\")\n      .replace(\"_\", \"/\");\n    return JSON.parse(atob(encodedPayload));\n  } catch (error) {\n    console.error(\"Problem decoding JWT payload\", error);\n  }\n}\n\nexport function throwFormattedError(error) {\n  if (!error) return;\n  if (typeof error === \"string\") throw new Error(error);\n  if (error?.response?.data?.message) {\n    throw new Error(error.response.data.message);\n  }\n  throw error;\n}\n","import { isTestHostname } from \"./utils.js\";\n\nexport const store = {\n  user: {},\n  tokens: {},\n  mode: isTestHostname() ? \"test\" : \"live\",\n};\n","import Cookies from \"js-cookie\";\n\nimport { store } from \"./store.js\";\n\nexport function setTokenNames() {\n  store.tokens = store.tokens || {};\n  store.tokens.accessTokenName = `access.${store.tenantId}`;\n  store.tokens.idTokenName = `id.${store.tenantId}`;\n  store.tokens.refreshTokenName = `refresh.${store.tenantId}`;\n}\n\n/**\n * Set and then return the access token\n */\nexport function accessToken() {\n  store.tokens.accessToken = Cookies.get(store.tokens.accessTokenName);\n  return store.tokens.accessToken;\n}\n\n/**\n * Set and then return the ID token\n */\nexport function idToken() {\n  store.tokens.idToken = Cookies.get(store.tokens.idTokenName);\n  return store.tokens.idToken;\n}\n\n/**\n * Define the store token values from the cookie values.\n */\nexport function setTokensFromCookies() {\n  const tokenNames = [\"access\", \"id\", \"refresh\"];\n  tokenNames.map((tokenName) => {\n    try {\n      const token = Cookies.get(store.tokens[`${tokenName}TokenName`]);\n      store.tokens[`${tokenName}Token`] = token;\n    } catch (error) {\n      console.warn(`Problem setting ${tokenName} token.`);\n    }\n  });\n}\n\n/**\n * Export the store.tokens object\n */\nexport const tokens = store.tokens;\n\n// NOTE Commenting this out 6/11/21 because the packages it relies on (jsonwebtoken & jwks-rsa)\n// both cause a lot of bloat. If we want to verify tokens, this is a nice way to do it, but\n// we need to find libraries designed for the browser instead of node.\n/**\n * Verify the provided token\n * @param {String} token\n * @returns {Promise<void>} The provided token has been verified if `verifyToken` resolves without error\n */\n// export async function verifyToken(token) {\n//   if (!token) throw new Error(\"Missing token\");\n\n//   let publicKey;\n//   try {\n//     const decodedToken = jwt.decode(token, { complete: true });\n//     if (!decodedToken.header || !decodedToken.header.kid) {\n//       throw new Error(\"Token kid not defined\");\n//     }\n\n//     const client = new JwksClient({\n//       jwksUri: `${apiUrl}tenants/${store.tenantId}/jwks/${store.mode}`,\n//       requestHeaders: { origin: window.location.origin },\n//     });\n\n//     const key = await client.getSigningKey(decodedToken.header.kid);\n//     publicKey = key.getPublicKey();\n//   } catch (error) {\n//     throw error;\n//   }\n\n//   if (!publicKey) {\n//     throw new Error(\"Public key not found\");\n//   }\n\n//   try {\n//     jwt.verify(token, publicKey);\n//   } catch (error) {\n//     throw new Error(\"Token verification failed\");\n//   }\n\n//   return Promise.resolve();\n// }\n","import Cookies from \"js-cookie\";\nimport { store } from \"./store.js\";\nimport { setTokensFromCookies } from \"./tokens.js\";\n\n/**\n * Set a cookie value based on the given options.\n * @param {String} value\n * @param {Object} options\n * @param {String} type\n */\nexport function setCookie(value, options, type) {\n  const cookieName = `${type}.${store.tenantId}`;\n  options = options || {\n    secure: store.mode === \"live\",\n    sameSite: \"Lax\",\n  };\n  if (type === \"refresh\") {\n    options.sameSite = \"Strict\";\n  }\n  Cookies.set(cookieName, value, options);\n}\n\n/**\n * Remove a cookie by name, regardless of its cookie setting(s).\n * @param {String} name\n */\nfunction removeCookie(name) {\n  Cookies.remove(name);\n  Cookies.remove(name, { secure: true, sameSite: \"Lax\" });\n  Cookies.remove(name, { secure: true, sameSite: \"None\" });\n  Cookies.remove(name, { secure: false, sameSite: \"Lax\" });\n  Cookies.remove(name, { secure: false, sameSite: \"None\" });\n}\n\n/**\n * Remove all auth cookies (access, id, refresh).\n */\nexport function removeAllCookies() {\n  removeCookie(store.tokens.accessTokenName);\n  removeCookie(store.tokens.idTokenName);\n  removeCookie(store.tokens.refreshTokenName);\n  store.tokens.accessToken = undefined;\n  store.tokens.idToken = undefined;\n  store.tokens.refreshToken = undefined;\n}\n\n/**\n * Set the cookies from a tokens object, and add to the local store.\n * @param {Object} tokens\n */\nexport function setCookiesAndTokens(tokens) {\n  setCookie(tokens.access.value, tokens.access.cookieOptions, \"access\");\n  setCookie(tokens.id.value, tokens.id.cookieOptions, \"id\");\n  if (tokens.refresh && tokens.refresh.value) {\n    setCookie(tokens.refresh.value, tokens.refresh.cookieOptions, \"refresh\");\n  }\n  setTokensFromCookies();\n}\n","import axios from \"axios\";\n\nimport { apiUrl } from \"./constants.js\";\nimport { store } from \"./store.js\";\nimport { removeAllCookies } from \"./cookies.js\";\n\n/**\n * Get the value of a query attribute, e.g. ?attr=value\n * @param {String} attrName\n */\nexport function getQueryAttr(attrName) {\n  if (\n    typeof window !== \"object\" ||\n    typeof window.location !== \"object\" ||\n    !window.location.href ||\n    window.location.href.indexOf(`${attrName}=`) < 0\n  ) {\n    return;\n  }\n  return decodeURIComponent(\n    window.location.href.split(`${attrName}=`)[1].split(\"&\")[0]\n  );\n}\n\n// TODO replace with direct check of the access token.\n/**\n * If the access token is valid, redirect the browser to the\n * tenant's login redirection path (path after login).\n */\nexport async function redirectIfLoggedIn() {\n  if (!store.tokens.accessToken) {\n    return removeAllCookies();\n  }\n  if (getQueryAttr(\"redirect\")) {\n    return redirectToPath(getQueryAttr(\"redirect\"));\n  }\n\n  try {\n    const { data } = await axios.get(`${apiUrl}self`, {\n      headers: {\n        authorization: `Bearer ${store.tokens.accessToken}`,\n      },\n    });\n    if (data.tenant && data.tenant.loginRedirectPath) {\n      redirectToPath(data.tenant.loginRedirectPath);\n    }\n  } catch (err) {\n    removeAllCookies();\n  }\n}\n\n/**\n * Redirect to path portion of a URL.\n */\nexport function redirectToPath(pathOrUrl, { redirect } = {}) {\n  // Return if redirect=false, or if SSR or mobile\n  if (\n    redirect === false ||\n    typeof document !== \"object\" ||\n    typeof window !== \"object\"\n  ) {\n    return;\n  }\n  try {\n    document && window;\n  } catch (error) {\n    return;\n  }\n\n  // If redirect is explicitly set, use that\n  if (!!redirect) pathOrUrl = redirect;\n\n  // If no pathOrUrl, do not redirect\n  if (!pathOrUrl) return;\n\n  // Perform hard redirect\n  const el = document.createElement(\"a\");\n  el.href = pathOrUrl;\n  let path = `${el.pathname}${el.hash}${el.search}`;\n  if (el.pathname !== window.location.pathname) {\n    window.location.assign(path);\n  }\n}\n","import axios from \"axios\";\nimport { apiUrl } from \"./constants.js\";\nimport { refresh } from \"./refresh.js\";\nimport { store } from \"./store.js\";\nimport { getJWTPayload } from \"./utils.js\";\n\n/**\n * Define the store.user object based on the ID token\n */\nexport function setUser() {\n  if (!store.tokens.idToken) {\n    return console.warn(\"Cannot define user: missing ID token\");\n  }\n\n  store.user = store.user || {};\n  const idTokenPayload = getJWTPayload(store.tokens.idToken);\n\n  // Set basic user information properties from ID token\n  const propsToDefine = [\n    \"email\",\n    \"username\",\n    \"name\",\n    \"image\",\n    \"data\",\n    \"confirmedAt\",\n    \"createdAt\",\n    \"updatedAt\",\n    \"mode\",\n    \"userId\",\n    \"userUuid\",\n    \"tenantId\",\n    \"isConfirmed\",\n  ];\n  for (const prop of propsToDefine) {\n    if (prop === \"update\") return;\n    store.user[prop] = idTokenPayload[prop];\n  }\n}\n\n/**\n * Update the user record on Userfront\n * @param {Object} payload User properties to update e.g. { name: 'John Doe' }\n */\nexport async function update(payload) {\n  if (!payload || Object.keys(payload).length < 1) {\n    return console.warn(\"Missing user properties to update\");\n  }\n\n  // Make request to update the user\n  await axios.put(`${apiUrl}self`, payload, {\n    headers: {\n      authorization: `Bearer ${store.tokens.accessToken}`,\n    },\n  });\n\n  // Refresh the access and ID tokens\n  await refresh();\n\n  // Set the store.user object from the ID token\n  setUser();\n\n  return store.user;\n}\n\n/**\n * Export the store.user object with the update method added\n */\nexport const user = store.user;\nuser.update = update;\n","import Cookies from \"js-cookie\";\nimport axios from \"axios\";\nimport { apiUrl } from \"./constants.js\";\nimport { setCookiesAndTokens } from \"./cookies.js\";\nimport { store } from \"./store.js\";\n// import { getIframe, postMessageAsPromise } from \"./iframe.js\";\nimport { setUser } from \"./user.js\";\n\n/**\n * Refresh the access and ID tokens\n * - When in test mode, uses the basic refresh method\n * - For tenants without a custom SSL certificate, uses the basic refresh method\n * - For tenants with a custom SSL certificate and in live mode, uses the httpOnly refresh method\n * @returns {Promise}\n */\nexport async function refresh() {\n  try {\n    await basicRefresh();\n    setUser();\n  } catch (error) {\n    console.warn(`Refresh failed: ${error.message}`);\n  }\n}\n\n/**\n * Use a regular (non-httpOnly) cookie to refresh the access and ID tokens.\n *\n * The basic refresh method is used automatically in test mode and in live\n * mode whenever an SSL certificate has not been set up.\n */\nasync function basicRefresh() {\n  const refreshToken = Cookies.get(store.tokens.refreshTokenName);\n  try {\n    const { data, status } = await axios.get(`${apiUrl}auth/refresh`, {\n      headers: {\n        authorization: `Bearer ${refreshToken}`,\n      },\n    });\n    if (status !== 200) {\n      throw new Error(data.message || \"Problem with request\");\n    }\n    if (data.tokens) {\n      setCookiesAndTokens(data.tokens);\n      return data;\n    } else {\n      throw new Error(\"Problem setting cookies\");\n    }\n  } catch (error) {\n    if (error?.response?.data?.message) {\n      throw new Error(error.response.data.message);\n    }\n    throw error;\n  }\n}\n\n// TODO re-enable httpOnly refresh method once new endpoints are stable [06/15/21]\n/**\n *\n * The httpOnly refresh method is only available for tenants with configured\n * SSL certificates while in live mode.\n */\n// async function httpOnlyRefresh() {\n//   const iframe = getIframe();\n//   if (!iframe) return;\n//   return postMessageAsPromise({\n//     type: \"refresh\",\n//     tenantId: store.tenantId,\n//   });\n// }\n\n/**\n * Use a sessionId and nonce to set the iframe refresh token\n * @param {String} sessionId\n * @param {String} nonce\n * @returns {Promise}\n */\nexport async function exchange({ sessionId, nonce }) {\n  return;\n\n  // TODO re-enable httpOnly exchange method once new endpoints are stable [06/15/21]\n  // --------------------------\n  // const iframe = getIframe();\n  // if (!iframe) return;\n  // return postMessageAsPromise({\n  //   type: \"exchange\",\n  //   tenantId: store.tenantId,\n  //   payload: {\n  //     sessionId,\n  //     nonce,\n  //   },\n  // });\n}\n","import axios from \"axios\";\nimport { apiUrl } from \"./constants.js\";\nimport { setCookiesAndTokens } from \"./cookies.js\";\nimport { store } from \"./store.js\";\nimport { getQueryAttr, redirectToPath } from \"./url.js\";\nimport { exchange } from \"./refresh.js\";\nimport { throwFormattedError } from \"./utils.js\";\n\n/**\n * This file has methods for signing up and logging in\n */\n\n/**\n * Register a user via the provided method. This method serves to call other\n * methods, depending on the \"method\" parameter passed in.\n * @param {String} method\n * @param {String} username\n * @param {String} name\n * @param {String} email\n * @param {String} password\n * @param {Object} data - Object for custom user fields\n * @param {String} redirect - path to redirect to, or if false, do not redirect\n */\nexport async function signup({\n  method,\n  username,\n  name,\n  email,\n  password,\n  data,\n  redirect,\n} = {}) {\n  if (!method) {\n    throw new Error('Userfront.signup called without \"method\" property.');\n  }\n  switch (method) {\n    case \"azure\":\n    case \"facebook\":\n    case \"github\":\n    case \"google\":\n    case \"linkedin\":\n      return signupWithSSO({ provider: method, redirect });\n    case \"password\":\n      return signupWithPassword({\n        username,\n        name,\n        email,\n        password,\n        userData: data,\n        redirect,\n      });\n    default:\n      throw new Error(\n        'Userfront.signup called with invalid \"method\" property.'\n      );\n  }\n}\n\n/**\n * Register a new user in via SSO provider.\n * Redirect the browser after successful authentication and 302 redirect from server.\n * @param {String} provider Name of SSO provider\n */\nfunction signupWithSSO({ provider, redirect }) {\n  if (!provider) throw new Error(\"Missing provider\");\n  const url = getProviderLink({ provider, redirect });\n  window.location.assign(url);\n}\n\n/**\n * Register a new user with username, name, email, and password.\n * Redirect the browser after successful signup based on the redirectTo value returned.\n * @param {String} username\n * @param {String} name\n * @param {String} email\n * @param {String} password\n * @param {Object} userData - alias for the user.data object, since \"data\" is used in the response\n * @param {String} redirect - do not redirect if false, or redirect to a specific path\n */\nasync function signupWithPassword({\n  username,\n  name,\n  email,\n  password,\n  userData,\n  redirect,\n} = {}) {\n  try {\n    const { data } = await axios.post(`${apiUrl}auth/create`, {\n      tenantId: store.tenantId,\n      username,\n      name,\n      email,\n      password,\n      data: userData,\n    });\n    if (data.tokens) {\n      setCookiesAndTokens(data.tokens);\n      await exchange(data);\n      redirectToPath(getQueryAttr(\"redirect\") || data.redirectTo || \"/\", {\n        redirect,\n      });\n      return data;\n    } else {\n      throw new Error(\"Please try again.\");\n    }\n  } catch (error) {\n    if (error?.response?.data?.message) {\n      throw new Error(error.response.data.message);\n    }\n    throw error;\n  }\n}\n\n/**\n * Log a user in via the provided method. This method serves to call other\n * methods, depending on the \"method\" parameter passed in.\n * @param {String} method\n * @param {String} email\n * @param {String} username\n * @param {String} emailOrUsername\n * @param {String} password\n * @param {String} token\n * @param {String} uuid\n * @param {String} redirect - do not redirect if false, or redirect to given path\n */\nexport async function login({\n  method,\n  email,\n  username,\n  emailOrUsername,\n  password,\n  token,\n  uuid,\n  redirect,\n} = {}) {\n  if (!method) {\n    throw new Error('Userfront.login called without \"method\" property.');\n  }\n  switch (method) {\n    case \"azure\":\n    case \"facebook\":\n    case \"github\":\n    case \"google\":\n    case \"linkedin\":\n      return loginWithSSO({ provider: method, redirect });\n    case \"password\":\n      return loginWithPassword({\n        email,\n        username,\n        emailOrUsername,\n        password,\n        redirect,\n      });\n    case \"link\":\n      return loginWithLink({ token, uuid, redirect });\n    default:\n      throw new Error('Userfront.login called with invalid \"method\" property.');\n  }\n}\n\n/**\n * Log a user in via SSO provider.\n * Redirect the browser after successful authentication and 302 redirect from server.\n * @param {String} provider Name of SSO provider\n * @param {String} redirect - do not redirect if false, or redirect to given path\n */\nfunction loginWithSSO({ provider, redirect }) {\n  if (!provider) throw new Error(\"Missing provider\");\n  const url = getProviderLink({ provider, redirect });\n  window.location.assign(url);\n}\n\nexport function getProviderLink({ provider, redirect }) {\n  if (!provider) throw new Error(\"Missing provider\");\n  if (!store.tenantId) throw new Error(\"Missing tenant ID\");\n\n  let url = `https://api.userfront.com/v0/auth/${provider}/login?tenant_id=${store.tenantId}&origin=${window.location.origin}`;\n\n  let redirectTo = redirect || getQueryAttr(\"redirect\");\n  if (redirect === false) {\n    redirectTo = typeof document === \"object\" && document.location.pathname;\n  }\n  if (redirectTo) {\n    url += `&redirect=${encodeURIComponent(redirectTo)}`;\n  }\n\n  return url;\n}\n\n/**\n * Log a user in with email/username and password.\n * Redirect the browser after successful login based on the redirectTo value returned.\n * @param {Object} options\n */\nasync function loginWithPassword({\n  email,\n  username,\n  emailOrUsername,\n  password,\n  redirect,\n}) {\n  try {\n    const { data } = await axios.post(`${apiUrl}auth/basic`, {\n      tenantId: store.tenantId,\n      emailOrUsername: email || username || emailOrUsername,\n      password,\n    });\n    if (data.tokens) {\n      setCookiesAndTokens(data.tokens);\n      await exchange(data);\n      redirectToPath(getQueryAttr(\"redirect\") || data.redirectTo || \"/\", {\n        redirect,\n      });\n      return data;\n    } else {\n      throw new Error(\"Please try again.\");\n    }\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\n/**\n * Log a user in with a token/uuid combo passed into the function or\n * in the URL querystring. ?token=...&uuid=...\n * @param {String} token\n * @param {UUID} uuid\n * @param {String} redirect - do not redirect if false, or redirect to given path\n */\nexport async function loginWithLink({ token, uuid, redirect } = {}) {\n  try {\n    token = token || getQueryAttr(\"token\");\n    uuid = uuid || getQueryAttr(\"uuid\");\n    if (!token || !uuid) return;\n\n    const { data } = await axios.put(`${apiUrl}auth/link`, {\n      token,\n      uuid,\n      tenantId: store.tenantId,\n    });\n\n    if (data.tokens) {\n      setCookiesAndTokens(data.tokens);\n      await exchange(data);\n      redirectToPath(getQueryAttr(\"redirect\") || data.redirectTo || \"/\", {\n        redirect,\n      });\n      return data;\n    } else {\n      throw new Error(\"Problem logging in.\");\n    }\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\n/**\n * Send a login link to the provided email.\n * @param {String} email\n */\nexport async function sendLoginLink(email) {\n  try {\n    const { data } = await axios.post(`${apiUrl}auth/link`, {\n      email,\n      tenantId: store.tenantId,\n    });\n    return data;\n  } catch (err) {\n    throw new Error(\"Problem sending link.\");\n  }\n}\n\n/**\n * Send a password reset link to the provided email.\n * @param {String} email\n */\nexport async function sendResetLink(email) {\n  try {\n    const { data } = await axios.post(`${apiUrl}auth/reset/link`, {\n      email,\n      tenantId: store.tenantId,\n    });\n    return data;\n  } catch (err) {\n    throw new Error(\"Problem sending link.\");\n  }\n}\n\nexport async function resetPassword({ uuid, token, password, redirect }) {\n  try {\n    token = token || getQueryAttr(\"token\");\n    uuid = uuid || getQueryAttr(\"uuid\");\n    if (!token || !uuid) throw new Error(\"Missing token or uuid\");\n    const { data } = await axios.put(`${apiUrl}auth/reset`, {\n      tenantId: store.tenantId,\n      uuid,\n      token,\n      password,\n    });\n    if (data.tokens) {\n      setCookiesAndTokens(data.tokens);\n      redirectToPath(getQueryAttr(\"redirect\") || data.redirectTo || \"/\", {\n        redirect,\n      });\n      return data;\n    } else {\n      throw new Error(\n        \"There was a problem resetting your password. Please try again.\"\n      );\n    }\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n","import { store } from \"./store.js\";\nimport {\n  tokens,\n  accessToken,\n  idToken,\n  setTokensFromCookies,\n  setTokenNames,\n} from \"./tokens\";\nimport { redirectIfLoggedIn } from \"./url.js\";\nimport {\n  login,\n  resetPassword,\n  sendLoginLink,\n  sendResetLink,\n  signup,\n} from \"./signon.js\";\nimport { logout } from \"./logout.js\";\nimport { setMode } from \"./mode.js\";\n// import { setIframe } from \"./iframe.js\";\nimport { user, setUser } from \"./user.js\";\nimport { isTestHostname } from \"./utils.js\";\nimport { refresh } from \"./refresh.js\";\n\nlet initCallbacks = [];\n\n/**\n * Initialize the Userfront library.\n * @param {String} tenantId\n */\nfunction init(tenantId) {\n  if (!tenantId) return console.warn(\"Userfront initialized without tenant ID\");\n  store.tenantId = tenantId;\n  setTokenNames();\n  // setIframe(); // TODO re-enable when iframe is needed\n  setTokensFromCookies();\n\n  if (store.tokens.idToken) {\n    setUser();\n  }\n\n  try {\n    if (initCallbacks.length > 0) {\n      initCallbacks.forEach((cb) => {\n        if (!cb || typeof cb !== \"function\") return;\n        cb({ tenantId });\n      });\n    }\n    initCallbacks = [];\n  } catch (error) {}\n}\n\n/**\n * Add a callback function to be called upon Userfront.init()\n * @param {Function} cb\n */\nfunction addInitCallback(cb) {\n  if (!cb || typeof cb !== \"function\") return;\n  initCallbacks.push(cb);\n}\n\n/**\n\n * Register a window-level event called \"urlchanged\" that will fire\n * whenever the browser URL changes.\n */\nlet isRegistered = false;\nfunction registerUrlChangedEventListener() {\n  if (isRegistered) return;\n  isRegistered = true;\n  try {\n    history.pushState = ((f) =>\n      function pushState() {\n        var ret = f.apply(this, arguments);\n        window.dispatchEvent(new Event(\"pushstate\"));\n        window.dispatchEvent(new Event(\"urlchanged\"));\n        return ret;\n      })(history.pushState);\n\n    history.replaceState = ((f) =>\n      function replaceState() {\n        var ret = f.apply(this, arguments);\n        window.dispatchEvent(new Event(\"replacestate\"));\n        window.dispatchEvent(new Event(\"urlchanged\"));\n        return ret;\n      })(history.replaceState);\n\n    window.addEventListener(\"popstate\", () => {\n      window.dispatchEvent(new Event(\"urlchanged\"));\n    });\n  } catch (error) {}\n}\n\n/**\n * EXPORTS\n */\n\nexport default {\n  // index\n  addInitCallback,\n  init,\n  registerUrlChangedEventListener,\n\n  //logout\n  logout,\n\n  // mode\n  setMode,\n\n  // refresh\n  refresh,\n\n  // signon\n  login,\n  resetPassword,\n  sendLoginLink,\n  sendResetLink,\n  signup,\n\n  // store\n  store,\n\n  // tokens\n  tokens,\n  accessToken,\n  idToken,\n\n  // url\n  redirectIfLoggedIn,\n\n  // user\n  user,\n\n  // utils\n  isTestHostname,\n};\n","import axios from \"axios\";\nimport { apiUrl } from \"./constants.js\";\n\nimport { getIframe, postMessageAsPromise } from \"./iframe.js\";\nimport { store } from \"./store.js\";\nimport { removeAllCookies } from \"./cookies.js\";\nimport { setTokensFromCookies } from \"./tokens.js\";\nimport { redirectToPath } from \"./url\";\n\n/**\n * Log a user out and redirect to the logout path.\n */\nexport async function logout() {\n  if (!store.tokens.accessToken) return removeAllCookies();\n  try {\n    const { data } = await axios.get(`${apiUrl}auth/logout`, {\n      headers: {\n        authorization: `Bearer ${store.tokens.accessToken}`,\n      },\n    });\n    removeAllCookies();\n    redirectToPath(data.redirectTo);\n  } catch (err) {\n    removeAllCookies();\n  }\n\n  // TODO re-enable exchange method once new endpoints are stable [06/15/21]\n  // --------------------------\n  // const iframe = getIframe();\n  // if (!iframe) return;\n  // try {\n  //   const { data } = await postMessageAsPromise({\n  //     type: \"logout\",\n  //     tenantId: store.tenantId,\n  //   });\n  //   removeAllCookies();\n  //   setTokensFromCookies();\n  //   redirectToPath(data.redirectTo || \"/\");\n  // } catch (error) {\n  //   removeAllCookies();\n  //   redirectToPath(\"/\");\n  // }\n}\n","import axios from \"axios\";\n\nimport { apiUrl } from \"./constants.js\";\nimport { store } from \"./store.js\";\n\n/**\n * Define the mode of operation (live or test)\n */\nexport async function setMode() {\n  try {\n    const { data } = await axios.get(`${apiUrl}tenants/${store.tenantId}/mode`);\n    store.mode = data.mode || \"test\";\n  } catch (err) {\n    store.mode = \"test\";\n  }\n}\n"],"names":["apiUrl","privateIPRegex","isTestHostname","hn","hostname","window","location","match","err","throwFormattedError","error","Error","response","_error$response","data","_error$response$data","message","store","user","tokens","mode","setTokensFromCookies","map","tokenName","token","Cookies","get","console","warn","setCookie","value","options","type","cookieName","tenantId","secure","sameSite","set","removeCookie","name","remove","removeAllCookies","accessTokenName","idTokenName","refreshTokenName","accessToken","undefined","idToken","refreshToken","setCookiesAndTokens","access","cookieOptions","id","refresh","getQueryAttr","attrName","href","indexOf","decodeURIComponent","split","redirectToPath","pathOrUrl","redirect","document","el","createElement","pathname","assign","hash","search","setUser","idTokenPayload","encodedPayload","replace","JSON","parse","atob","getJWTPayload","propsToDefine","prop","body","recover","result","e","then","update","payload","Object","keys","length","axios","put","headers","authorization","exchange","status","basicRefresh","getProviderLink","provider","url","origin","redirectTo","encodeURIComponent","initCallbacks","isRegistered","addInitCallback","cb","push","init","forEach","registerUrlChangedEventListener","history","pushState","f","ret","apply","this","arguments","dispatchEvent","Event","replaceState","addEventListener","logout","setMode","login","method","email","username","emailOrUsername","password","uuid","loginWithSSO","post","loginWithPassword","loginWithLink","resetPassword","sendLoginLink","sendResetLink","signup","signupWithSSO","userData","signupWithPassword","redirectIfLoggedIn","tenant","loginRedirectPath"],"mappings":"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"}